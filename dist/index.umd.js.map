{"version":3,"file":"index.umd.js","sources":["../src/utils/getBasicImageProps.js","../src/defaults.js","../src/utils/helpers.js","../src/utils/buildImageUrl.js","../src/utils/cacheImageInfo.js","../src/getFixedGatsbyImage.js","../src/getFluidGatsbyImage.js"],"sourcesContent":["const validImageUrlPattern = /^\\/\\/a.storyblok.com\\/f\\/[0-9]+\\/[0-9]+x[0-9]+\\/[A-Za-z0-9]+\\/[\\S]+\\.[a-z]+/\n\nfunction getBasicImageProps(image) {\n  let url = null\n  let lqip = null\n\n  if (typeof image === 'string') {\n    url = image\n  }\n\n  if (typeof image === 'object') {\n    url = image.image\n    lqip = image.base64 ? image.base64 : null\n  }\n\n  url = validImageUrlPattern.test(url) ? url : null\n\n  if (!url) {\n    return false\n  }\n\n  let originalPath = url.replace('//a.storyblok.com/', '')\n\n  let [, , dimensions, , filename] = originalPath.split('/')\n  let [width, height] = dimensions.split('x').map(num => parseInt(num, 10))\n  let [, extension] = filename.split('.')\n\n  let aspectRatio = width / height\n  let metadata = { dimensions: { width, height, aspectRatio }, lqip }\n\n  return {\n    originalPath,\n    extension,\n    metadata\n  }\n}\n\nexport default getBasicImageProps\n","import path from 'path'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\nexport const STORYBLOK_BASE_URL = 'https://img2.storyblok.com'\nexport const CACHE_DIR = path.resolve(`.cache/storyblok/assets/`)\n\nexport const sizeMultipliersFixed = [1, 1.5, 2, 3]\nexport const sizeMultipliersFluid = [0.25, 0.5, 1, 1.5, 2, 3]\n\nexport const defaultOptions = {\n  quality: 100,\n  smartCrop: true,\n  format: null,\n  fill: null,\n  toFormat: null,\n  base64: null,\n  useBase64: true\n}\n\nexport const defaultFluidOptions = {\n  ...defaultOptions,\n  maxWidth: DEFAULT_FLUID_MAX_WIDTH,\n  maxHeight: null\n}\n\nexport const defaultFixedOptions = {\n  ...defaultOptions,\n  width: DEFAULT_FIXED_WIDTH,\n  height: null\n}\n","export function applyFilters(filters) {\n  return filters.reduce((acc, currentFilter, i) => {\n    return `${acc}:${currentFilter}`\n  }, '/filters')\n}\n\nexport function isWebP(url) {\n  const isConverted = url.includes('filters:format(webp)')\n  const isOriginal = /[a-f0-9]+-\\d+x\\d+\\.webp/.test(url)\n  return isConverted || isOriginal\n}\n\nexport function transformSrcSet(srcSet, suffix = '') {\n  return srcSet\n    .map(src => {\n      const [url, dim] = src.split(' ')\n      const imageName = url.split('/').slice(-1)\n      return `/static/${dim}--${imageName}${suffix} ${dim}`\n    })\n    .join(',\\n')\n}","import { STORYBLOK_BASE_URL } from '../defaults'\nimport { applyFilters } from './helpers'\n\nfunction buildImageUrl(originalPath, image) {\n  let { width, height, smartCrop, quality, format, fill } = image\n\n  let [, extension] = originalPath.split('.')\n\n  let url = STORYBLOK_BASE_URL\n\n  if (width && height) {\n    url += `/${width}x${height}`\n  }\n\n  if (smartCrop) {\n    url += `/smart`\n  }\n\n  let filters = [\n    ...[quality && `quality:(${quality})`],\n    ...[format && format !== extension && `format:(${format})`],\n    ...[fill && `fill:(${fill})`]\n  ]\n\n  // remove falsy elements\n  filters = filters.filter(element => Boolean(element) === true)\n\n  if (filters.length > 0) {\n    url += applyFilters(filters)\n  }\n\n  // add original path at the end\n  url += `/${originalPath}`\n\n  return url\n}\n\nexport default buildImageUrl\n","import { resolve } from 'path'\nimport { CACHE_DIR } from '../defaults'\n\nexport default function cacheImageInfo({ imageName, src, srcWebp, srcSets }) {\n  if (typeof window === 'undefined') {\n    // importing fs cause issues with gatsby-image\n    const fs = require('fs-extra')\n\n    const filePath = resolve(CACHE_DIR + '/' + imageName)\n    fs.pathExists(filePath + '.json').then(exists => {\n      if (!exists) {\n        fs.writeJsonSync(filePath + '.json', {\n          name: imageName,\n          src,\n          srcSet: srcSets.base,\n          srcWebp,\n          srcSetWebp: srcSets.webp,\n        })\n      }\n    })\n  }\n}\n","import getBasicImageProps from './utils/getBasicImageProps'\nimport buildUrl from './utils/buildImageUrl'\nimport { isWebP, transformSrcSet } from './utils/helpers'\nimport { sizeMultipliersFixed, defaultFixedOptions } from './defaults'\nimport cacheImageInfo from './utils/cacheImageInfo'\n\nfunction getFixedGatsbyImage(image, args = {}) {\n  let imageProps = getBasicImageProps(image)\n\n  if (!imageProps) {\n    return null\n  }\n\n  let options = {\n    ...defaultFixedOptions,\n    ...args\n  }\n\n  let { width, height, base64, useBase64 } = options\n  let {\n    metadata: { dimensions, lqip },\n    originalPath\n  } = imageProps\n\n  let desiredAspectRatio = dimensions.aspectRatio\n\n  // If we're cropping, calculate the specified aspect ratio\n  if (options.height) {\n    desiredAspectRatio = width / options.height\n  }\n\n  let forceConvert = null\n  if (options.toFormat) {\n    forceConvert = options.toFormat\n  } else if (isWebP(originalPath)) {\n    forceConvert = 'jpg'\n  }\n\n  let widths = sizeMultipliersFixed.map(scale => Math.round(width * scale))\n  let initial = { webp: [], base: [] }\n\n  let srcSets = widths\n    .filter(currentWidth => currentWidth < dimensions.width)\n    .reduce((acc, currentWidth, i) => {\n      let resolution = `${sizeMultipliersFixed[i]}x`\n      let currentHeight = Math.round(currentWidth / desiredAspectRatio)\n\n      let size = {\n        ...options,\n        width: currentWidth,\n        height: currentHeight\n      }\n\n      let webpUrl = buildUrl(originalPath, {\n        ...size,\n        ...{ format: 'webp' }\n      })\n\n      let baseUrl = buildUrl(originalPath, {\n        ...size,\n        ...(forceConvert && { format: forceConvert })\n      })\n\n      acc.webp.push(`${webpUrl} ${resolution}`)\n      acc.base.push(`${baseUrl} ${resolution}`)\n\n      return acc\n    }, initial)\n\n  let outputHeight = Math.round(height ? height : width / desiredAspectRatio)\n\n  let imgSize = {\n    ...options,\n    width: width,\n    height: outputHeight\n  }\n\n  let src = buildUrl(originalPath, {\n    ...imgSize,\n    ...(forceConvert && { format: forceConvert })\n  })\n\n  let srcWebp = buildUrl(originalPath, {\n    ...imgSize,\n    ...{ format: 'webp' }\n  })\n\n  const isProduction = process.env.NODE_ENV === 'production'\n  let srcPath, srcSetPath, srcWebpPath, srcSetWebpPath\n\n  if (isProduction && options.saveLocal) {\n    const [url] = src.split(' ')\n    const imageName = url.split('/').slice(-1)\n    cacheImageInfo({ imageName, src, srcSets, srcWebp })\n    srcPath = `/static/${imageName}`\n    srcSetPath = transformSrcSet(srcSets.base)\n    srcWebpPath = `/static/${imageName}.webp`\n    srcSetWebpPath = transformSrcSet(srcSets.base, '.webp')\n  } else {\n    srcPath = src\n    srcSetPath = srcSets.base.join(',\\n') || null\n    srcWebpPath = srcWebp\n    srcSetWebpPath = srcSets.webp.join(',\\n') || null\n  }\n\n  // base64String\n  \n\n  return {\n    base64: image.base64 || null,\n    aspectRatio: desiredAspectRatio,\n    width: Math.round(width),\n    height: outputHeight,\n    src: srcPath,\n    srcSet: srcSetPath,\n    srcWebp: srcWebpPath,\n    srcSetWebp: srcSetWebpPath,\n  }\n}\n\nexport default getFixedGatsbyImage\n","import getBasicImageProps from './utils/getBasicImageProps'\nimport buildUrl from './utils/buildImageUrl'\nimport { isWebP, transformSrcSet } from './utils/helpers'\nimport { sizeMultipliersFluid, defaultFluidOptions } from './defaults'\nimport cacheImageInfo from './utils/cacheImageInfo';\n\nfunction getFluidGatsbyImage(image, args = {}) {\n  let imageProps = getBasicImageProps(image)\n\n  if (!imageProps) {\n    return null\n  }\n\n  let options = {\n    ...defaultFluidOptions,\n    ...args\n  }\n\n  let { maxWidth, base64, useBase64 } = options\n\n  let {\n    metadata: { dimensions, lqip },\n    originalPath\n  } = imageProps\n\n  let desiredAspectRatio = dimensions.aspectRatio\n\n  // If we're cropping, calculate the specified aspect ratio\n  if (options.maxHeight) {\n    desiredAspectRatio = maxWidth / options.maxHeight\n  }\n\n  let maxHeight = options.maxHeight || Math.round(maxWidth / dimensions.aspectRatio)\n\n  let forceConvert = null\n  if (options.toFormat) {\n    forceConvert = options.toFormat\n  } else if (isWebP(originalPath)) {\n    forceConvert = 'jpg'\n  }\n\n  let sizes = options.sizes || `(max-width: ${maxWidth}px) 100vw, ${maxWidth}px`\n  let widths = sizeMultipliersFluid\n    .map(scale => Math.round(maxWidth * scale))\n    .filter(width => width < dimensions.width)\n    .concat(dimensions.width)\n\n  let initial = { webp: [], base: [] }\n  let srcSets = widths\n    .filter(currentWidth => currentWidth < dimensions.width)\n    .reduce((acc, currentWidth) => {\n      let currentHeight = Math.round(currentWidth / desiredAspectRatio)\n\n      let size = {\n        width: currentWidth,\n        height: currentHeight\n      }\n\n      let webpUrl = buildUrl(originalPath, {\n        ...options,\n        ...size,\n        ...{ format: 'webp' }\n      })\n\n      let baseUrl = buildUrl(originalPath, {\n        ...options,\n        ...size,\n        ...{ format: forceConvert }\n      })\n\n      acc.webp.push(`${webpUrl} ${currentWidth}w`)\n      acc.base.push(`${baseUrl} ${currentWidth}w`)\n      return acc\n    }, initial)\n\n  let imgSize = { width: maxWidth, height: maxHeight }\n\n  let src = buildUrl(originalPath, {\n    ...options,\n    ...imgSize,\n    ...{ format: forceConvert }\n  })\n\n  let srcWebp = buildUrl(originalPath, {\n    ...options,\n    ...imgSize,\n    ...{ format: 'webp' }\n  })\n\n  const isProduction = process.env.NODE_ENV === 'production'\n  let srcPath, srcSetPath, srcWebpPath, srcSetWebpPath\n\n  if (isProduction && options.saveLocal) {\n    const [url] = src.split(' ')\n    const imageName = url.split('/').slice(-1)\n    cacheImageInfo({ imageName, src, srcSets, srcWebp })\n    srcPath = `/static/${imageName}`\n    srcSetPath = transformSrcSet(srcSets.base)\n    srcWebpPath = `/static/${imageName}.webp`\n    srcSetWebpPath = transformSrcSet(srcSets.base, '.webp')\n  } else {\n    srcPath = src\n    srcSetPath = srcSets.base.join(',\\n') || null\n    srcWebpPath = srcWebp\n    srcSetWebpPath = srcSets.webp.join(',\\n') || null\n  }\n\n  return {\n    base64: image.base64 || null,\n    aspectRatio: desiredAspectRatio,\n    src: srcPath,\n    srcSet: srcSetPath,\n    srcWebp: srcWebpPath,\n    srcSetWebp: srcSetWebpPath,\n    sizes,\n  }\n}\n\nexport default getFluidGatsbyImage\n"],"names":["validImageUrlPattern","getBasicImageProps","image","url","lqip","base64","test","originalPath","replace","split","map","num","parseInt","filename","dimensions","width","height","const","STORYBLOK_BASE_URL","CACHE_DIR","resolve","sizeMultipliersFixed","sizeMultipliersFluid","defaultOptions","quality","smartCrop","format","fill","toFormat","useBase64","defaultFluidOptions","Object","maxWidth","maxHeight","defaultFixedOptions","isWebP","isConverted","includes","isOriginal","transformSrcSet","srcSet","suffix","src","dim","slice","join","buildImageUrl","filters","filter","element","Boolean","length","reduce","acc","currentFilter","i","applyFilters","cacheImageInfo","ref","window","fs","require","filePath","imageName","pathExists","then","exists","writeJsonSync","name","srcSets","base","srcWebp","srcSetWebp","webp","args","imageProps","options","desiredAspectRatio","aspectRatio","forceConvert","srcPath","srcSetPath","srcWebpPath","srcSetWebpPath","scale","Math","round","currentWidth","resolution","currentHeight","size","webpUrl","buildUrl","baseUrl","push","outputHeight","imgSize","process","env","NODE_ENV","saveLocal","sizes","concat"],"mappings":"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"}